<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <title>Alessio Leo</title>

    <script>
        function Flex(id){
            let box = document.getElementById(id);
            box.classList.remove('none');
            box.classList.add('flex');
        }
        function Hide(id){
            let box = document.getElementById(id);
            box.classList.remove('flex');
            box.classList.add('hidden');
        }
        function Block(id){
            let box = document.getElementById(id);
            box.classList.remove('hidden');
            box.classList.add('block');
        }
        function Home(){
            Hide('projects');
            //Hide('timeline');
            Flex('boxinfo');
        }
        function Projects(){
            Hide('boxinfo');
            //Hide('timeline');
            Flex('projects');
        }
        function Carreer(){
            Hide('projects');
            Hide('boxinfo');
            Block('timeline');
        }
    </script>
</head>
<body>

<video autoplay muted loop playsinline id="sfondoanimato">
    <source src="../Assets/space.mp4" type="video/mp4">
    Your browser does not support the video.
    If you are on safari, turn off power saving mode to autoplay the background.
</video>

<div id="topbar">
    <ul id="topbar_list" class="glass">
        <li onclick="Home()">HOME</a></li>
        <li onclick="Projects()">PROJECTS</li>
        <!--<li onclick="Carreer()">CAREER</li>-->
    </ul>
</div>

<div id="boxinfo" class="glass2">
    <div id="col1">
        <span class="name" style="width: fit-content">Alessio Leo</span>
        <span class="info" style="user-select: none;">Bachelor's Degree in Computer Enginnering</span>
        <span class="info" style="user-select: none;">Master's Degree Student</span>
        <span class="info" style="user-select: none;">Salerno, Italy</span>
        <span class="info" style="user-select: none;">born: 19 December 2003 </span>
        <a href="mailto:a.leo88@studenti.unisa.it"><span class="info" style="user-select: none;">a.leo88@studenti.unisa.it</span></a>
        <a href="mailto:alessio003@icloud.com"><span class="info" style="user-select: none;">alessio003@icloud.com</span></a>
    </div>
    <div id="col2">
        <a href="https://www.linkedin.com/in/alessio-leo-635aa8359/"><img src="../Assets/LinkedIn_logo.svg" class="logo1"></a>
        <a href="https://github.com"><img src="../Assets/GitHub_Lockup_Light.png" class="logo1"></a>
    </div>
</div>

<div id="projects">
    <div id="Ai" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold; color: #ff00ae">Agente Ai - Pilota Automatico</span>
            <img src="../Assets/Ai.png" class="copertina_prog" >
            <p>
                Durante un corso della laurea triennale, come parte dell’esame, è stato svolto in gruppo un progetto finalizzato allo sviluppo di un algoritmo in grado di guidare autonomamente un veicolo in ambiente simulato. L’obiettivo era realizzare un sistema di controllo che prendesse decisioni in tempo reale sulla base dei dati provenienti da sensori virtuali, quali la posizione sulla pista e la distanza dai bordi, utilizzati per simulare il comportamento di un sensore LIDAR.
                Il progetto è stato sviluppato utilizzando Java e Python, facendo uso della libreria scikit-learn e in particolare di un classificatore k-nearest neighbors. Durante la fase di progettazione ho approfondito le tecniche di selezione delle feature e di bilanciamento del dataset, aspetti fondamentali per garantire prestazioni robuste sia in condizioni standard di guida sia in situazioni critiche come uscite di pista, testacoda o curve complesse a S. Per affrontare il problema dello sbilanciamento dei dati, ho proposto e implementato autonomamente l’introduzione di un meccanismo di controllo che permettesse di decidere se registrare o meno i dati nel dataset, evitando così di accumulare grandi quantità di campioni relativi ai tratti rettilinei a discapito delle situazioni più rare ma critiche. Questa soluzione si è rivelata particolarmente efficace e più immediata rispetto ad approcci alternativi più complessi.
                Un’ulteriore tecnica adottata per la costruzione del dataset è stata l’utilizzo di una macchina esterna come server del simulatore, separata dal sistema su cui veniva eseguito lo script del pilota automatico. In questo modo è stato possibile addestrare e testare l’algoritmo in condizioni non ideali, introducendo latenze di comunicazione realistiche e simili a quelle presenti il giorno dell’esame, in cui il simulatore e il controller erano eseguiti su macchine diverse collegate tramite rete. Il progetto si è concluso con risultati di gara eccellenti, riuscendo a completare tutti e tre i giri previsti in tempi molto competitivi. La valutazione finale del progetto è stata pari a 28/30.</p>
        </div>
    </div>
    <div id="Tw" class="contenitore">

        <div style="padding: 1rem">
            <span style="font-weight: bold; color: #ffff00">Outer Space</span>
            <img src="../Assets/OuterSpace.png" class="copertina_prog">
            <p>
                Come lavoro finale del corso di Tecnologie Web della laurea triennale, è stato sviluppato in gruppo un sito web multipagina con piena libertà progettuale e con il vincolo di utilizzare tutte le tecnologie affrontate durante il corso: HTML, CSS, JavaScript, PHP e PostgreSQL. Il progetto è stato realizzato seguendo una struttura ordinata e modulare, prevedendo per ogni pagina file separati per HTML, CSS, JavaScript e PHP, così da migliorare la leggibilità, la manutenibilità e l’organizzazione del codice. Oltre alle tecnologie richieste, sono state integrate funzionalità avanzate come l’uso di HTML5 per la geolocalizzazione, l’integrazione di Stripe per la simulazione dei pagamenti e diverse API esterne per l’acquisizione automatica di informazioni.
                Il sito, denominato Outer Space, è un e-commerce completo e funzionante dedicato a ipotetici viaggi spaziali, progettato per riprodurre il comportamento e le caratteristiche di una piattaforma di commercio elettronico moderna. Presenta una homepage differenziata per utenti autenticati e non, un catalogo prodotti con aggiunta dinamica al carrello tramite AJAX, un sistema di supporto basato su form e API per il contatto email, un sistema di autenticazione sviluppato in PHP con interfaccia frontend in popup e limitazioni di accesso basate sulla posizione geografica dell’utente, e un carrello gestito lato client tramite cookie con aggiornamenti asincroni per migliorare l’esperienza utente. Il processo di acquisto si completa con una pagina di checkout che simula il pagamento tramite Stripe, rendendo il flusso di acquisto realistico e completo.
                Sono inoltre presenti funzionalità avanzate come la visualizzazione dello storico degli ordini dell’utente tramite interrogazioni al database, pagine dinamiche di errore e conferma richiamate via PHP con gestione di codici di stato, una sezione informativa sullo spazio alimentata da API esterne e utilizzata anche per sperimentare soluzioni di design, una pagina di presentazione del team, un sistema di registrazione utenti con memorizzazione dei dati in database SQL e una pagina dedicata alla generazione del biglietto di viaggio. Quest’ultima produce dinamicamente un ticket contenente tutte le informazioni dell’acquisto, inclusa la generazione di un QR code funzionante.
                Dal punto di vista personale, il progetto ha rappresentato un’esperienza di particolare interesse formativo, permettendomi di applicare in modo concreto tecnologie oggi ampiamente utilizzate in ambito professionale. Spinto da questo interesse, ho curato autonomamente sia lo sviluppo frontend che backend di numerose componenti fondamentali del sito, tra cui il sistema di login e registrazione, la gestione del carrello e della topbar, la pagina di supporto, lo storico degli ordini, la generazione dei ticket e le pagine dinamiche di errore e conferma. L’esame si è concluso con una valutazione finale di 29/30, ottenuta sia nella parte teorica sia nella parte pratica legata al progetto.
            </p>
        </div>
    </div>
    <div id="Swe" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold; color: #00f0ff">Rubrica Telefonica</span>
            <img src="../Assets/Rubrica.png" class="copertina_prog">
            <p>
                Al termine del corso di Software Engineering, come parte della valutazione finale, è stato richiesto di applicare le conoscenze teoriche acquisite attraverso la realizzazione, in gruppo, di un software di rubrica telefonica sviluppato in Java. Il progetto è partito dall’analisi di un documento iniziale volutamente grezzo, dal quale è stato necessario estrarre e formalizzare le specifiche di sistema, conducendo un’accurata analisi dei requisiti e una successiva assegnazione delle priorità, mettendo in pratica i principali concetti di ingegneria del software affrontati durante il corso.
                A questa fase è seguita la progettazione, che ha incluso la realizzazione dei diagrammi di classe, di sequenza, dei casi d’uso e dei package, fornendo una visione strutturata e coerente dell’architettura del sistema. Successivamente si è passati alla fase di implementazione, sviluppando l’applicazione in Java con interfaccia grafica basata su JavaFX e SceneBuilder, applicando in parallelo i principi della programmazione orientata agli oggetti. Durante questa fase è stato utilizzato anche Doxygen per la generazione automatica della documentazione del codice.
                In linea con il ciclo di vita completo del software, è stata poi condotta una fase di testing mediante unit test realizzati con JUnit, al fine di verificare il corretto funzionamento delle funzionalità implementate e individuare eventuali anomalie. Il progetto si è concluso con il rilascio dell’applicazione nella sua versione finale sotto forma di file JAR e con la redazione di una relazione tecnica descrittiva della metodologia adottata. L’intero processo di sviluppo è stato supportato dall’uso di Git e GitHub per il version control, rendendo il progetto, sebbene apparentemente semplice, un lavoro di discreta complessità e completezza, capace di coprire tutte le fasi fondamentali dello sviluppo software.
                Su mia proposta e realizzazione è stata inoltre implementata una funzionalità di supporto completo allo standard VCF, rendendo la rubrica interoperabile con la maggior parte delle applicazioni di gestione dei contatti attualmente in commercio. Il progetto si è concluso con una valutazione finale di 27/30.
            </p>
        </div>
    </div>
    <div id="Mp" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold; color: #ff4400">BiblioTech</span>
            <img src="../Assets/BiblioTech.png" class="copertina_prog">
            <p>
                Come requisito d’esame del corso di laurea triennale Mobile Programming, è stata realizzata in gruppo un’applicazione di gestione di una libreria digitale per smartphone, progettata per essere multi-piattaforma. L’applicazione è stata sviluppata utilizzando Flutter, con SQLite per la persistenza dei dati relativi alla libreria e alle attività di lettura, e con l’ausilio di Xcode per la simulazione e il testing sia su dispositivi fisici sia su emulatori.
                L’app presenta una schermata principale dinamica, caratterizzata da sezioni dedicate ai libri recenti o consigliati, e consente l’aggiunta rapida di nuovi titoli e la visualizzazione dei preferiti. Il sistema di inserimento dei libri sfrutta le API di Google Books per ottenere dati realistici e completi, mantenendo comunque la possibilità di aggiungere manualmente libri non presenti nel catalogo online. È inoltre presente una libreria completa che mostra tutti i libri inseriti, con funzionalità di ricerca testuale e applicazione di filtri per categoria.
                Ogni libro dispone di una pagina dedicata in cui è possibile visualizzare e modificare i dettagli, nonché aggiungere note personali relative alla lettura. L’applicazione include infine una sezione di statistiche che fornisce una panoramica sui tempi di lettura, sul numero di libri letti, sui generi più frequenti e su altri indicatori utili. Il progetto si è concluso con una valutazione finale di 30/30.
            </p>
        </div>
    </div>
    <div id="Nms" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold; color: #7b00ff">Configurazione office Network</span>
            <img src="../Assets/Nms.png" class="copertina_prog">
            <p>
                Per l’esame del corso di laurea triennale Network Management and Security è stato richiesto, in gruppo, di progettare e configurare da zero una rete complessa sulla base di uno schema fornito, occupandosi della configurazione completa di tutti i componenti, dai router con firewall ai server presenti nell’infrastruttura, garantendo il rispetto puntuale delle specifiche di sicurezza e di accesso. Il progetto è stato realizzato utilizzando GNS3, software di riferimento per la simulazione avanzata di reti.
                La rete era strutturata su più perimetri di sicurezza, comprendendo due reti interne distinte e una DMZ. Nel primo perimetro interno erano presenti due host generici e un server DHCP, mentre il secondo perimetro ospitava un sistema di rilevamento delle intrusioni e un database server. La DMZ era dedicata a un web server esposto verso l’esterno. La configurazione prevedeva che tutte le macchine potessero accedere a Internet, ad eccezione del server DHCP, dell’IDS e del database server, ai quali era consentito esclusivamente l’accesso ai rispettivi repository software per operazioni di aggiornamento, mediante regole firewall altamente restrittive.
                Il web server è stato configurato utilizzando Apache e ospitava un’installazione di WordPress, con persistenza dei dati su un database remoto collocato nel perimetro interno dedicato. L’accesso al web server era consentito sia dall’esterno della rete sia dagli host interni, esclusivamente tramite protocollo HTTPS. Dal perimetro interno principale, solo uno degli host era autorizzato ad accedere al database tramite connessione SSH, mentre il web server poteva comunicare con il database in modo limitato allo schema utilizzato dal CMS. Il database è stato inoltre protetto da possibili attacchi di tipo DoS mediante opportune configurazioni di sicurezza.
                Il server DHCP è stato configurato per distribuire indirizzi IP in un range predefinito agli host interni, mentre l’IDS, basato su Snort, è stato impiegato per l’analisi del traffico nel perimetro dedicato, utilizzando una configurazione standard. Ogni macchina disponeva sia di un firewall locale sia delle protezioni perimetrali di rete, implementate tramite macchine virtuali con sistema OPNSense, responsabili della gestione centralizzata delle regole di filtraggio e sicurezza.
                Il progetto si è concluso con una valutazione finale di 30/30 e ha rappresentato un’esperienza particolarmente formativa, consentendomi di applicare in modo approfondito le nozioni teoriche del corso e di acquisire esperienza pratica nella configurazione reale dei principali componenti di una rete di media complessità, con particolare attenzione agli aspetti di sicurezza e segmentazione.
            </p>
        </div>
    </div>
    <div id="Minervas" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold; color: #00ff03">Algoritmo di Controllo della Congestione realizzato con Machine Learning</span>
            <img src="../Assets/Minervas.png" class="copertina_prog">
            <p>
                Durante il tirocinio curriculare della laurea triennale ho svolto 200 ore presso Minervas, startup attiva nel settore della mobilità ecosostenibile e intelligente, lavorando su un progetto nell’ambito delle comunicazioni V2X. In questo contesto ho sviluppato, in ambiente simulato, un algoritmo di controllo della congestione della comunicazione tra due macchine virtuali Linux collegate tramite VPN. L’algoritmo si basa su un classificatore k-nearest neighbors addestrato mediante tecniche di machine learning su dataset ottenuti da misurazioni di rete effettuate sotto differenti condizioni di carico.
                Sulla base della classificazione dello stato della rete, l’algoritmo adatta dinamicamente la frequenza di trasmissione di messaggi periodici, facendo riferimento a scenari realistici di comunicazione V2X. I risultati hanno mostrato un miglioramento significativo delle prestazioni in presenza di reti dinamiche o congestionate, consentendo di mantenere sempre la massima frequenza di trasmissione compatibile con le condizioni di rete del momento. L’attività svolta ha avuto un ruolo centrale ed è stata successivamente approfondita e sviluppata come argomento della tesi di laurea triennale.
                Nelle ore di tirocinio rimanenti ho inoltre avviato la configurazione di una simulazione di traffico urbano utilizzando il simulatore Veins, realizzando autonomamente lo scenario urbano a partire da mappe OpenStreetMap e impiegando SUMO e OMNeT++ per la simulazione, rispettivamente, del traffico veicolare e della rete di comunicazione. La simulazione è stata configurata per scenari di traffico sia a bassa sia ad alta densità; tuttavia, per vincoli temporali, non è stato possibile integrare tale ambiente simulativo con l’algoritmo di controllo della congestione sviluppato in precedenza.
            </p>
        </div>
    </div>
</div>

</body>
</html>