<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="style.css">
    <title>Alessio Leo</title>

    <script>
        function Flex(id){
            let box = document.getElementById(id);
            box.classList.remove('none');
            box.classList.add('flex');
        }
        function Hide(id){
            let box = document.getElementById(id);
            box.classList.remove('flex');
            box.classList.add('hidden');
        }
        function Home(){
            Hide('projects');
            Flex('boxinfo');
        }
        function Projects(){
            Hide('boxinfo');
            Flex('projects')
        }
        function Projects2(){
            Hide('projects')
            Hide('boxinfo');
        }
    </script>
</head>
<body>

<video autoplay muted loop playsinline id="sfondoanimato">
    <source src="../Assets/space.mp4" type="video/mp4">
    Your browser does not support the video.
    If you are on safari, turn off power saving mode to autoplay the background.
</video>

<div id="topbar">
    <ul id="topbar_list" class="glass">
        <li onclick="Home()">HOME</a></li>
        <li onclick="Projects()">PROJECTS</li>
        <li onclick="Projects2()">CAREER</li>
    </ul>
</div>

<div id="boxinfo" class="glass2">
    <div id="col1">
        <span class="name">Alessio Leo</span>
        <span class="info" style="user-select: none;">Bachelor's Degree in Computer Enginnering</span>
        <span class="info" style="user-select: none;">Master's Degree Student</span>
        <span class="info" style="user-select: none;">Salerno, Italy</span>
        <span class="info" style="user-select: none;">born: 19 December 2003 </span>
        <a href="mailto:a.leo88@studenti.unisa.it"><span class="info" style="user-select: none;">a.leo88@studenti.unisa.it</span></a>
        <a href="mailto:alessio003@icloud.com"><span class="info" style="user-select: none;">alessio003@icloud.com</span></a>
    </div>
    <div id="col2">
        <a href="https://www.linkedin.com/in/alessio-leo-635aa8359/"><img src="../Assets/LinkedIn_logo.svg" class="logo1"></a>
        <a href="https://github.com"><img src="../Assets/GitHub_Lockup_Light.png" class="logo1"></a>
    </div>
</div>

<div id="projects">
    <div id="Ai" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold">Agente Ai - Pilota Automatico</span>
            <img src="../Assets/Ai.png" class="copertina_prog" >
            <p>
                Durante il corso nella laurea triennale come parte dell'esame in gruppi da 4 ci è stato assegnato il compito di sviluppare un algoritmo in grado di guidare autonomamente una macchina in ambiente simulato tenendo conto di una serie di sensori come posizione in pista e distanza dai bordi per simulare un lidar.
                Il progetto si è svolto in java e python usufruendo della libreria scikit-learn con un classificatore k-nn
                Durante la fase di progettazione ho appreso metodi per la decisione delle feature e bilanciamento del dataset per avere prestazioni ottimali in ogni situazione da un'uscita di pista a casi di curve ad S più complesse. Durante la fase di addestramento per bilanciare il dataset di mia iniziativa ho deciso di proporre l’introduzione di un interruttore per decidere se registrare o meno i dati nel dataset in modo da non avere decine di km di rettilineo e pochi metri in casi di fuoristrada, testa-coda o inconvenienti vari e questa soluzione si è rivelata fondamentale nel risolvere un problema in maniera più efficiente di altre soluzioni meno immediate. Un'ulteriore tecnica utilizzata per realizzare il dataset è stata quella di usare un pc esterno al simulatore come server in modo da addestrare il pilota automatico con condizioni non ottimali sulla stessa macchina ma con ritardi verosimili a quelli del giorno dell’esame dove lo script del pilota automatico girava sul proprio portatile e il simulatore su una macchina server con di mezzo un router. Il progetto si è concluso con risultati di gara eccellenti riuscendo a completare tutti e 3 i giri prestabiliti in tempi record. Valutazione del progetto 28/30.
            </p>
        </div>
    </div>
    <div id="Tw" class="contenitore">

        <div style="padding: 1rem">
            <span style="font-weight: bold">Outer Space</span>
            <img src="../Assets/OuterSpace.png" class="copertina_prog">
            <p>
                Come lavoro finale per il corso “Tecnologie Web” della triennale ci è stata data massima libertà a gruppi di 4 per lo sviluppo di un sito web multipagina con il vincolo di dover utilizzare tutte le tecnologie studiate (html, css, javascript, php, postgress). Il sito è stato strutturato in modo da avere per ogni pagina il file html, css, javascript e php per avere una maggior organizzazione. Sono state usate le seguenti tecnologie oltre quelle precedentemente elencate, html5 come per la geolocalizzazione, stripe e varie api per la raccolta di informazioni automatiche. Il nostro sito chiamato outer space è un eshop completo e funzionante di ipotetici viaggi spaziali. Presenta tutte le caratteristiche funzionali e di sicurezza di un e-commerce moderno strutturato dalle seguenti pagine:
                Homepage - composta da versioni diverse per utente loggato e non
                Catalogo - catalogo dei prodotti acquistabili con aggiunta al carrello ajax
                Supporto - un form dove tramite semplici api permetteva di contattare un email di supporto
                Login in come pop up - gestione del login in php e con frontend caratterizzato da un popup e limiti geografici in quanto con javascript abbiamo dato l’accesso solo se l’utente risultava collegato da determinati paesi da noi scelti.
                Carrello come pop  up - Carrello gestito con i cookie lato client e con modifiche gestite da ajax per migliorare l’esperienza utente
                Check out - pagina di conferma dell'ordine con simulazione del pagamento con Stripe, fondamentale per averci consentito di avere un sito funzionante a 360 gradi
                Storico Acquisti - Una pagina che recupera da un database lo storico degli ordini effettuati dal account con il quale si è effettuato l’accesso e informazioni generali come numero ordine o giorni alla partenza.
                Una pagina di errore o conferma dinamica - due pagine richiamabili tramite php per casi di errore o conferma con la possibilità di aggiungere codici alla chiamata in modo da mostrare contenuti affini al codice (es cod.1 acquisto completato, cod.2 registrazione completata…)
                Space History - pagina con informazioni genetiche sullo spazio ottenute da api e per sperimentare alcune tecniche di design
                About us - una pagina con i dettagli di noi ideatori del sito
                Pagina registrazione - un form atto alla gestione della registrazione dell'utente con memorizzazione in un database sql
                Pagina ticket - Una pagina che tramite query al server ed api, genera un biglietto con tutte le informazioni del viaggio acquistato e un qr code funzionante

                Personalmente ritengo questo esame essere stato molto di mio interesse in quanto spinto da determinazione nel voler imparare tecniche e tecnologie che al giorno d’oggi sono utili per ogni evenienza e nella stragrande maggioranza dei settori. Proprio per questo mio interesse personale sono riuscito a mettere in pratica autonomamente tutte le tecnologie richieste nel progetto sia per back end che front end in quanto ho gestito completamente le funzionalità di login, registrazione, carrello, topbar, pagina supporto, storico ordini, ticket e le pagine dinamiche di errore e conferma.
                L’esame si è concluso con una votazione di 29/30 sia per la parte teorica che pratica con il progetto.
            </p>
        </div>
    </div>
    <div id="Swe" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold">Rubrica Telefonica</span>
            <img src="../Assets/Rubrica.png" class="copertina_prog">
            <p>
                Alla fine del corso di Software Engineering come parte valutativa ci è stato chiesto di applicare le conoscenze studiate realizzando un software di rubrica telefonica in java a gruppi di 4. Ci è stato assegnato un documento grezzo da cui estrarre tutte le specifiche necessarie facendo un analisi dei requisiti con una successiva assegnazione delle priorità mettendo in pratica i concetti teorici studiati. Successivamente abbiamo fatto una fase di progettazione composta dai vari diagrammi di classe, sequenza, casi d’uso e package. In seguito poi si è passati sulla parte implementativa in java e javafx con scenebuilder (in questo modo abbiamo applicato in contemporanea le conoscenze del corso di programmazione ad oggetti), in questa fase abbiamo utilizzato anche doxygen per la generazione automatica di documentazione. Per continuare il ciclo di vita di un software abbiamo eseguito una fase di testing con unit test e Junit per garantire il corretto funzionamento del software e scoprire eventuali malfunzionamenti. In fine il software è stato rilasciato come file jar nella sua versione finale e redatta una relazione per descrivere la metodologia applicata. In tutto il processo produttivo si è usufruito di git e in particolare di github per il version control rendendo questo progetto seppur a prima vista “semplice”, ma in realtà di modesta complessità, un progetto completo in grado di aver applicato tutte le conoscenze acquisite durante le lezioni. Tra le funzionalità della rubrica su mia proposta e realizzazione è stato deciso di implementare il supporto completo allo standard VCF per rendere il software interfacciabile con la maggior parte delle rubriche digitali in commercio.
                Il progetto si è concluso con votazione 27/30.
            </p>
        </div>
    </div>
    <div id="Mp" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold">BiblioTech</span>
            <img src="../Assets/BiblioTech.png" class="copertina_prog">
            <p>
                Come requisito d’esame per il corso della triennale chiamato “mobile programming" ci è stata la realizzazione in gruppi di 4 di un'app di libreria per smartphone e multi-os.
                L’applicazione è stata sviluppata in flutter con l’utilizzo di sqlite per la persistenza della libreria e dei dati di lettura e l’utilizzo di xcode per avere una simulazione sia su dispositivi fisici che virtuali.
                La home è caratterizzata da una sezione dinamica con libri recenti o consigliati, permette l’aggiunta rapida di un libro o la visualizzazione dei preferiti. L’aggiunta funziona tramite api Google per avere dati e scenari reali, ma presenta anche la possibilità di aggiungere libri non disponibili su google book. L’app presenta una libreria dove vengono mostrati tutti i libri aggiunti e con la possibilità di effettuare una ricerca o l’applicazione di filtri per categorie. Ogni libro ha tutti i dettagli visualizzabili nella pagina dedicata ed eventualmente modificati e/o aggiungere delle note alla lettura. Infine l’app presenta una schermata di statistiche con tempi di lettura, libri letti, genere e altro.
                L’applicazione è stata valutata con votazione 30/30.
            </p>
        </div>
    </div>
    <div id="Nms" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold">Configurazione office Network</span>
            <img src="../Assets/Nms.png" class="copertina_prog">
            <p>
                Per l’esame della triennale “Network Management and Security” in gruppi di 4 ci è stato dato il compito di gestire la configurazione di rete in figura configurando da zero ogni singolo componente dai firewall dei router ai vari server presenti in rete, gestendo come richiesto dalle specifiche i vari accessi. Si è usufruito del software di simulazione GNS3 leader nel settore delle simulazioni di rete.
                In particolare la struttura della rete era cosi caratterizzata:
                perimetro interno (P1) in cui sono presenti due host ed un server DHCP;
                perimetro interno (P2) in cui sono presenti un IDS ed un database server;
                DMZ in cui è presente un web server.
                e con le seguenti specifiche:
                Tutte le macchine devono poter navigare all’esterno ad eccezione di:
                server DHCP
                IDS
                database server
                queste macchine devono solo poter accedere ai repository quando è necessario effettuare degli aggiornamenti software (dobbiamo inserire una regola nel firewall per ognuna di queste 3 macchine che deve consentire solo il traffico per il rispettivo repository, DHCP-Server → deve poter accedere solo a ipDest: “isc-dhcp-server” se si può fare con il nome di dominio da OPNSens altrimenti indirizzo ip IDS → DB → )
                Il web server deve essere realizzato tramite il servizio apache, su questo va installato il CMS Wordpress, il quale memorizza i dati sul database server
                Il web server deve essere accessibile dall’esterno della rete e dai due host interni.
                Dal perimetro P1, Solo l’host 1 deve poter accedere al database tramite connessione SSH.
                Il web server deve poter accedere al database, limitatamente allo schema utilizzato dal CMS.
                Il web server deve consentire solo la comunicazione tramite il protocollo HTTPS.
                Il server DHCP distribuisce gli indirizzi nel range [2-50] ai due host generici.
                L’IDS deve essere utilizzato per analizzare il traffico nel perimetro P2 e può essere basato sul software snort.
                E’ possibile utilizzare una configurazione standard
                E’ necessario proteggere il database da attacchi DoS
                Ogni macchina deve avere il proprio firewall locale oltre ad i firewall presenti all’interno della rete.
                I firewall devono essere realizzati tramite una macchina virtuale con sistema OPNSens.
                Questo progetto è stato valutato con votazione 30/30 e mi ha permesso di mettere in pratica in maniera molto approfondita le nozioni teoriche fornite dal corso, nonché configurare con mano i principali componenti di una rete di complessità media.

            </p>
        </div>
    </div>
    <div id="Minervas" class="contenitore">
        <div style="padding: 1rem">
            <span style="font-weight: bold">Algoritmo di Controllo della Congestione realizzato con Machine Learning</span>
            <img src="../Assets/Minervas.png" class="copertina_prog">
            <p>
                Durante il tirocinio curriculare della triennale ho svolto 200 ore presso minervas (startup attiva nel settore della mobilità ecosostenibile ed intelligente) su un progetto nell'ambito v2x, ho avuto modo di realizzare in ambiente simulato un algoritmo di controllo della congestione di comunicazione tra due macchine virtuali linux e vpn. L’algoritmo sfrutta un classificatore K-nn basato su un modello di machine learning addestrato su dataset provenienti da misurazioni della rete sotto vari carichi. L’algoritmo in base alla classificazione della rete adatta automaticamente la frequenza di trasmissione di messaggi periodici alla base di scenari reali di v2x. Tale algoritmo ha dimostrato un ottimo incremento delle performance in caso di rete dinamica o congestionata adattandosi sempre con la massima frequenza di trasmissione possibile in quello scenario, inoltre l’algoritmo è stato anche argomento della tesi triennale.
                Successivamente nelle ore di tirocinio restanti ho iniziato a configurare una simulazione di traffico urbano con il simulatore veins creando autonomamente lo scenario urbano da una mappa di openstreetmap e  usufruendo di sumo e omnet++ per la simulazione rispettivamente del traffico e della rete veicolare. Tale simulazione è stata configurata negli scenari di traffico basso e denso ma non è stata integrata con l’algoritmo di controllo precedentemente descritto per limiti di tempo.
            </p>
        </div>
    </div>
</div>

</body>
</html>